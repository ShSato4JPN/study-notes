# React Compositionパターン

React Compositionパターンは、コンポーネントの再利用性と柔軟性を高めるための設計パターンです。継承ではなく合成（composition）を使って、コンポーネント間の関係を構築します。

## 概要

Compositionパターンでは、親コンポーネントが子コンポーネントの構造や内容を決定するのではなく、子コンポーネントを受け取って組み合わせます。これにより、より柔軟で再利用可能なコンポーネントを作成できます。

主な利点：

- コンポーネントの責任が明確に分離される
- 再利用性が向上する
- プロップドリリング問題を軽減できる
- より柔軟なUI構造を実現できる

## サンプルコード上記のサンプルコードでは、React Compositionパターンの4つの主要な手法を実装しています

## 1. Children Props パターン

最もシンプルな合成パターンで、`children` propを使って子要素を受け取ります。Cardコンポーネントのように、外殻となるコンポーネントの中身を外部から決定できます。

## 2. Render Props パターン

関数をpropとして受け取り、その関数にデータを渡してレンダリングを委譲します。DataFetcherコンポーネントでは、データの取得ロジックとUIの表示を分離しています。

## 3. Compound Components パターン

複数のコンポーネントが協調して動作するパターンです。Dropdownコンポーネントのように、関連するコンポーネントをまとめて、統一されたAPIを提供します。

## 4. Higher-Order Component (HOC) パターン

コンポーネントを受け取って、機能を追加した新しいコンポーネントを返します。認証チェックのような横断的関心事を分離できます。

これらのパターンを適切に使い分けることで、保守性が高く再利用可能なReactアプリケーションを構築できます。

## 1. Children Props パターン

```jsx
import React from 'react';
import { User, Bell } from 'lucide-react';

// Children Props パターン - 基本的なCard系コンポーネント
const Card = ({ children, className = '' }) => {
  return (
    <div className={`bg-white rounded-lg shadow-md p-6 ${className}`}>
      {children}
    </div>
  );
};

const CardHeader = ({ children }) => {
  return <div className="border-b pb-4 mb-4">{children}</div>;
};

const CardBody = ({ children }) => {
  return <div className="text-gray-700">{children}</div>;
};

// 使用例
const ChildrenPropsDemo = () => {
  return (
    <div className="max-w-2xl mx-auto p-6 bg-gray-50 min-h-screen space-y-6">
      <div className="bg-white p-4 rounded-lg">
        <h2 className="text-2xl font-bold mb-2">Children Props パターン</h2>
        <p className="text-gray-600">
          コンポーネントの内容を外部から注入できるパターン。
          <code className="bg-gray-100 px-2 py-1 rounded">children</code> propを使って、
          親コンポーネントが子要素の構造を決定します。
        </p>
      </div>

      {/* 基本的な使用例 */}
      <Card>
        <CardHeader>
          <h3 className="text-xl font-bold">ユーザー情報</h3>
        </CardHeader>
        <CardBody>
          <div className="flex items-center gap-3">
            <User className="w-8 h-8 text-blue-500" />
            <div>
              <p className="font-semibold">田中太郎</p>
              <p className="text-sm text-gray-500">tanaka@example.com</p>
            </div>
          </div>
        </CardBody>
      </Card>

      {/* スタイルを追加した使用例 */}
      <Card className="border-l-4 border-green-500">
        <CardBody>
          <div className="flex items-center gap-3">
            <Bell className="w-6 h-6 text-green-500" />
            <p>通知: 新しいメッセージがあります</p>
          </div>
        </CardBody>
      </Card>

      {/* ネストした使用例 */}
      <Card>
        <CardHeader>
          <h3 className="text-xl font-bold">設定項目</h3>
        </CardHeader>
        <CardBody>
          <div className="space-y-3">
            <Card className="bg-gray-50 shadow-sm">
              <CardBody>
                <p className="font-medium">プロフィール設定</p>
                <p className="text-sm text-gray-500">名前、メールアドレスの変更</p>
              </CardBody>
            </Card>
            <Card className="bg-gray-50 shadow-sm">
              <CardBody>
                <p className="font-medium">プライバシー設定</p>
                <p className="text-sm text-gray-500">公開範囲、データの取り扱い</p>
              </CardBody>
            </Card>
          </div>
        </CardBody>
      </Card>

      <div className="bg-blue-50 p-4 rounded-lg">
        <div className="text-sm">
          <p className="font-semibold text-blue-800 mb-2">✅ メリット:</p>
          <ul className="text-blue-700 space-y-1">
            <li>• シンプルで理解しやすい</li>
            <li>• 高い再利用性</li>
            <li>• 柔軟なレイアウト構成</li>
          </ul>
        </div>
      </div>
    </div>
  );
};

export default ChildrenPropsDemo;
```

## 2. Render Props パターン

```jsx
import React, { useState, useEffect } from 'react';
import { User, RefreshCw, Loader } from 'lucide-react';

// Render Props パターン - データ取得ロジックを分離
const DataFetcher = ({ render }) => {
  const [data, setData] = useState([
    { id: 1, name: '田中太郎', email: 'tanaka@example.com', status: 'active' },
    { id: 2, name: '佐藤花子', email: 'sato@example.com', status: 'inactive' },
    { id: 3, name: '鈴木一郎', email: 'suzuki@example.com', status: 'active' }
  ]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const refreshData = () => {
    setLoading(true);
    setError(null);

    // 擬似的なAPI呼び出し
    setTimeout(() => {
      try {
        const newUser = {
          id: data.length + 1,
          name: `新しいユーザー${data.length + 1}`,
          email: `user${data.length + 1}@example.com`,
          status: Math.random() > 0.5 ? 'active' : 'inactive'
        };
        setData(prev => [...prev, newUser]);
        setLoading(false);
      } catch (err) {
        setError('データの取得に失敗しました');
        setLoading(false);
      }
    }, 1000);
  };

  const deleteUser = (id) => {
    setData(prev => prev.filter(user => user.id !== id));
  };

  return render({ data, loading, error, refreshData, deleteUser });
};

// マウス位置を追跡するRender Props コンポーネント
const MouseTracker = ({ render }) => {
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMouseMove = (e) => {
      setMousePosition({ x: e.clientX, y: e.clientY });
    };

    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);

  return render(mousePosition);
};

// 基本的なCard コンポーネント（再利用）
const Card = ({ children, className = '' }) => (
  <div className={`bg-white rounded-lg shadow-md p-6 ${className}`}>
    {children}
  </div>
);

const CardHeader = ({ children }) => (
  <div className="border-b pb-4 mb-4">{children}</div>
);

const CardBody = ({ children }) => (
  <div className="text-gray-700">{children}</div>
);

// メインコンポーネント
const RenderPropsDemo = () => {
  return (
    <div className="max-w-4xl mx-auto p-6 bg-gray-50 min-h-screen space-y-6">
      <div className="bg-white p-4 rounded-lg">
        <h2 className="text-2xl font-bold mb-2">Render Props パターン</h2>
        <p className="text-gray-600">
          関数をpropsとして受け取り、その関数にデータを渡してレンダリングを委譲するパターン。
          データの取得ロジックとUIの表示を完全に分離できます。
        </p>
      </div>

      {/* データ取得の例 */}
      <DataFetcher
        render={({ data, loading, error, refreshData, deleteUser }) => (
          <Card>
            <CardHeader>
              <div className="flex justify-between items-center">
                <h3 className="text-xl font-bold">ユーザー一覧</h3>
                <button
                  onClick={refreshData}
                  disabled={loading}
                  className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:opacity-50 transition-colors"
                >
                  {loading ? (
                    <Loader className="w-4 h-4 animate-spin" />
                  ) : (
                    <RefreshCw className="w-4 h-4" />
                  )}
                  {loading ? '読み込み中...' : 'データ更新'}
                </button>
              </div>
            </CardHeader>
            <CardBody>
              {error && (
                <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded mb-4">
                  {error}
                </div>
              )}
              <div className="space-y-3">
                {data.map(user => (
                  <div key={user.id} className="flex items-center justify-between p-3 bg-gray-50 rounded-md">
                    <div className="flex items-center gap-3">
                      <User className="w-5 h-5 text-gray-500" />
                      <div>
                        <div className="flex items-center gap-2">
                          <p className="font-medium">{user.name}</p>
                          <span className={`px-2 py-1 text-xs rounded-full ${
                            user.status === 'active'
                              ? 'bg-green-100 text-green-800'
                              : 'bg-gray-100 text-gray-800'
                          }`}>
                            {user.status}
                          </span>
                        </div>
                        <p className="text-sm text-gray-500">{user.email}</p>
                      </div>
                    </div>
                    <button
                      onClick={() => deleteUser(user.id)}
                      className="px-3 py-1 text-sm text-red-600 hover:bg-red-50 rounded-md transition-colors"
                    >
                      削除
                    </button>
                  </div>
                ))}
              </div>
            </CardBody>
          </Card>
        )}
      />

      {/* 同じデータを違う表示形式で */}
      <DataFetcher
        render={({ data }) => (
          <Card>
            <CardHeader>
              <h3 className="text-xl font-bold">ユーザー統計</h3>
            </CardHeader>
            <CardBody>
              <div className="grid grid-cols-3 gap-4">
                <div className="text-center p-4 bg-blue-50 rounded-lg">
                  <p className="text-2xl font-bold text-blue-600">{data.length}</p>
                  <p className="text-sm text-blue-800">総ユーザー数</p>
                </div>
                <div className="text-center p-4 bg-green-50 rounded-lg">
                  <p className="text-2xl font-bold text-green-600">
                    {data.filter(u => u.status === 'active').length}
                  </p>
                  <p className="text-sm text-green-800">アクティブ</p>
                </div>
                <div className="text-center p-4 bg-gray-50 rounded-lg">
                  <p className="text-2xl font-bold text-gray-600">
                    {data.filter(u => u.status === 'inactive').length}
                  </p>
                  <p className="text-sm text-gray-800">非アクティブ</p>
                </div>
              </div>
            </CardBody>
          </Card>
        )}
      />

      {/* マウストラッカーの例 */}
      <MouseTracker
        render={({ x, y }) => (
          <Card className="bg-gradient-to-r from-purple-50 to-pink-50">
            <CardBody>
              <div className="text-center">
                <h3 className="text-lg font-semibold mb-2">マウストラッカー</h3>
                <p className="text-gray-600">
                  マウスの現在位置: <span className="font-mono font-bold">({x}, {y})</span>
                </p>
                <div className="mt-4 h-2 bg-gray-200 rounded-full overflow-hidden">
                  <div
                    className="h-full bg-gradient-to-r from-purple-500 to-pink-500 transition-all duration-100"
                    style={{ width: `${Math.min((x / window.innerWidth) * 100, 100)}%` }}
                  />
                </div>
              </div>
            </CardBody>
          </Card>
        )}
      />

      <div className="bg-green-50 p-4 rounded-lg">
        <div className="text-sm">
          <p className="font-semibold text-green-800 mb-2">✅ メリット:</p>
          <ul className="text-green-700 space-y-1">
            <li>• データロジックとUIロジックの完全な分離</li>
            <li>• 同じデータソースで複数の表示形式が可能</li>
            <li>• 高度な再利用性</li>
            <li>• テストしやすい構造</li>
          </ul>
        </div>
      </div>
    </div>
  );
};

export default RenderPropsDemo;
```

## 3. Compound Components パターン

```jsx
import React, { useState, createContext, useContext } from 'react';
import { ChevronDown, User, Settings, Bell, LogOut, Plus, Minus } from 'lucide-react';

// Compound Components パターン - Dropdown
const DropdownContext = createContext();

const Dropdown = ({ children }) => {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <DropdownContext.Provider value={{ isOpen, setIsOpen }}>
      <div className="relative">
        {children}
      </div>
    </DropdownContext.Provider>
  );
};

const DropdownTrigger = ({ children }) => {
  const { isOpen, setIsOpen } = useContext(DropdownContext);

  return (
    <button
      onClick={() => setIsOpen(!isOpen)}
      className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors"
    >
      {children}
      <ChevronDown className={`w-4 h-4 transition-transform ${isOpen ? 'rotate-180' : ''}`} />
    </button>
  );
};

const DropdownMenu = ({ children }) => {
  const { isOpen } = useContext(DropdownContext);

  if (!isOpen) return null;

  return (
    <div className="absolute top-full left-0 mt-2 bg-white border rounded-md shadow-lg min-w-48 z-10">
      {children}
    </div>
  );
};

const DropdownItem = ({ children, onClick }) => {
  const { setIsOpen } = useContext(DropdownContext);

  const handleClick = () => {
    onClick?.();
    setIsOpen(false);
  };

  return (
    <button
      onClick={handleClick}
      className="w-full text-left px-4 py-2 hover:bg-gray-100 transition-colors flex items-center gap-2"
    >
      {children}
    </button>
  );
};

// Compound Components パターン - Accordion
const AccordionContext = createContext();

const Accordion = ({ children, allowMultiple = false }) => {
  const [openItems, setOpenItems] = useState(new Set());

  const toggleItem = (id) => {
    setOpenItems(prev => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        if (!allowMultiple) {
          newSet.clear();
        }
        newSet.add(id);
      }
      return newSet;
    });
  };

  return (
    <AccordionContext.Provider value={{ openItems, toggleItem }}>
      <div className="border border-gray-200 rounded-lg overflow-hidden">
        {children}
      </div>
    </AccordionContext.Provider>
  );
};

const AccordionItem = ({ children, id }) => {
  return (
    <div className="border-b border-gray-200 last:border-b-0">
      {React.Children.map(children, child =>
        React.cloneElement(child, { id })
      )}
    </div>
  );
};

const AccordionHeader = ({ children, id }) => {
  const { openItems, toggleItem } = useContext(AccordionContext);
  const isOpen = openItems.has(id);

  return (
    <button
      onClick={() => toggleItem(id)}
      className="w-full px-4 py-3 text-left bg-gray-50 hover:bg-gray-100 transition-colors flex items-center justify-between"
    >
      <span className="font-medium">{children}</span>
      <ChevronDown className={`w-4 h-4 transition-transform ${isOpen ? 'rotate-180' : ''}`} />
    </button>
  );
};

const AccordionContent = ({ children, id }) => {
  const { openItems } = useContext(AccordionContext);
  const isOpen = openItems.has(id);

  if (!isOpen) return null;

  return (
    <div className="px-4 py-3 bg-white">
      {children}
    </div>
  );
};

// Compound Components パターン - Counter
const CounterContext = createContext();

const Counter = ({ children, initialValue = 0, min = 0, max = 100 }) => {
  const [count, setCount] = useState(initialValue);

  const increment = () => setCount(prev => Math.min(prev + 1, max));
  const decrement = () => setCount(prev => Math.max(prev - 1, min));
  const reset = () => setCount(initialValue);

  return (
    <CounterContext.Provider value={{ count, increment, decrement, reset, min, max }}>
      <div className="flex items-center gap-2">
        {children}
      </div>
    </CounterContext.Provider>
  );
};

const CounterDisplay = ({ className = '' }) => {
  const { count } = useContext(CounterContext);

  return (
    <span className={`px-4 py-2 bg-gray-100 rounded-md font-mono text-lg ${className}`}>
      {count}
    </span>
  );
};

const CounterButton = ({ children, action, className = '' }) => {
  const { increment, decrement, reset, count, min, max } = useContext(CounterContext);

  const handleClick = () => {
    switch (action) {
      case 'increment':
        increment();
        break;
      case 'decrement':
        decrement();
        break;
      case 'reset':
        reset();
        break;
    }
  };

  const isDisabled =
    (action === 'increment' && count >= max) ||
    (action === 'decrement' && count <= min);

  return (
    <button
      onClick={handleClick}
      disabled={isDisabled}
      className={`px-3 py-2 rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed ${className}`}
    >
      {children}
    </button>
  );
};

// 使用例
const CompoundComponentsDemo = () => {
  return (
    <div className="max-w-4xl mx-auto p-6 bg-gray-50 min-h-screen">
      <h1 className="text-2xl font-bold mb-6">Compound Components パターン</h1>

      <div className="space-y-8">
        <div className="bg-white p-4 rounded-lg border">
          <h3 className="font-semibold mb-2">概要</h3>
          <p className="text-sm text-gray-600">
            複数のコンポーネントが協調して動作するパターン。
            関連するコンポーネントをグループ化し、統一されたAPIを提供します。
            Contextを使用して状態を共有することが多いです。
          </p>
        </div>

        {/* Dropdown の例 */}
        <div className="bg-white rounded-lg shadow-md p-6">
          <h2 className="text-lg font-semibold mb-4">Dropdown コンポーネント</h2>

          <div className="space-y-4">
            <div>
              <h3 className="font-medium mb-2">ユーザーメニュー</h3>
              <Dropdown>
                <DropdownTrigger>
                  <User className="w-4 h-4" />
                  田中太郎
                </DropdownTrigger>
                <DropdownMenu>
                  <DropdownItem onClick={() => alert('プロフィール編集')}>
                    <User className="w-4 h-4" />
                    プロフィール編集
                  </DropdownItem>
                  <DropdownItem onClick={() => alert('設定')}>
                    <Settings className="w-4 h-4" />
                    設定
                  </DropdownItem>
                  <DropdownItem onClick={() => alert('通知')}>
                    <Bell className="w-4 h-4" />
                    通知
                  </DropdownItem>
                  <DropdownItem onClick={() => alert('ログアウト')}>
                    <LogOut className="w-4 h-4" />
                    ログアウト
                  </DropdownItem>
                </DropdownMenu>
              </Dropdown>
            </div>

            <div>
              <h3 className="font-medium mb-2">アクションメニュー</h3>
              <Dropdown>
                <DropdownTrigger>
                  <Settings className="w-4 h-4" />
                  アクション
                </DropdownTrigger>
                <DropdownMenu>
                  <DropdownItem onClick={() => alert('新規作成')}>
                    新規作成
                  </DropdownItem>
                  <DropdownItem onClick={() => alert('インポート')}>
                    インポート
                  </DropdownItem>
                  <DropdownItem onClick={() => alert('エクスポート')}>
                    エクスポート
                  </DropdownItem>
                </DropdownMenu>
              </Dropdown>
            </div>
          </div>
        </div>

        {/* Accordion の例 */}
        <div className="bg-white rounded-lg shadow-md p-6">
          <h2 className="text-lg font-semibold mb-4">Accordion コンポーネント</h2>

          <Accordion allowMultiple={true}>
            <AccordionItem id="faq1">
              <AccordionHeader>React Compositionパターンとは何ですか？</AccordionHeader>
              <AccordionContent>
                <p className="text-gray-700">
                  React Compositionパターンは、コンポーネントの再利用性と柔軟性を高めるための設計パターンです。
                  継承ではなく合成を使って、コンポーネント間の関係を構築します。
                </p>
              </AccordionContent>
            </AccordionItem>

            <AccordionItem id="faq2">
              <AccordionHeader>どのような種類がありますか？</AccordionHeader>
              <AccordionContent>
                <p className="text-gray-700">
                  主な種類として、Children Props、Render Props、Compound Components、
                  Higher-Order Components (HOC) があります。それぞれ異なる用途と利点があります。
                </p>
              </AccordionContent>
            </AccordionItem>

            <AccordionItem id="faq3">
              <AccordionHeader>いつ使用すべきですか？</AccordionHeader>
              <AccordionContent>
                <p className="text-gray-700">
                  コンポーネントの再利用性を高めたい場合、プロップドリリング問題を回避したい場合、
                  または複雑なUIロジックを分離したい場合に使用します。
                </p>
              </AccordionContent>
            </AccordionItem>
          </Accordion>
        </div>

        {/* Counter の例 */}
        <div className="bg-white rounded-lg shadow-md p-6">
          <h2 className="text-lg font-semibold mb-4">Counter コンポーネント</h2>

          <div className="space-y-4">
            <div>
              <h3 className="font-medium mb-2">基本的なカウンター</h3>
              <Counter initialValue={0} min={0} max={10}>
                <CounterButton action="decrement" className="bg-red-500 text-white hover:bg-red-600">
                  <Minus className="w-4 h-4" />
                </CounterButton>
                <CounterDisplay />
                <CounterButton action="increment" className="bg-green-500 text-white hover:bg-green-600">
                  <Plus className="w-4 h-4" />
                </CounterButton>
                <CounterButton action="reset" className="bg-gray-500 text-white hover:bg-gray-600">
                  リセット
                </CounterButton>
              </Counter>
            </div>

            <div>
              <h3 className="font-medium mb-2">商品数量選択</h3>
              <div className="flex items-center gap-4">
                <span className="text-sm">数量:</span>
                <Counter initialValue={1} min={1} max={99}>
                  <CounterButton action="decrement" className="bg-blue-500 text-white hover:bg-blue-600">
                    -
                  </CounterButton>
                  <CounterDisplay className="min-w-16 text-center" />
                  <CounterButton action="increment" className="bg-blue-500 text-white hover:bg-blue-600">
                    +
                  </CounterButton>
                </Counter>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div className="mt-8 bg-purple-50 p-4 rounded-lg">
        <h3 className="font-semibold text-purple-800 mb-2">メリット</h3>
        <ul className="text-sm text-purple-700 space-y-1">
          <li>• 関連するコンポーネントをグループ化できる</li>
          <li>• 柔軟で直感的なAPI設計が可能</li>
          <li>• コンポーネント間の状態共有が簡単</li>
          <li>• 拡張性が高い</li>
        </ul>
      </div>
    </div>
  );
};

export default CompoundComponentsDemo;
```

## 4. Higher-Order Component (HOC) パターン

```jsx
import React, { useState, useEffect } from 'react';
import { User, Shield, Clock, Loader, AlertCircle, Activity, Database } from 'lucide-react';

// HOC パターン - 認証チェック
const withAuth = (WrappedComponent) => {
  return (props) => {
    const [isAuthenticated, setIsAuthenticated] = useState(false);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
      // 認証チェックのシミュレーション
      setTimeout(() => {
        setIsAuthenticated(Math.random() > 0.3); // 70%の確率で認証成功
        setIsLoading(false);
      }, 1000);
    }, []);

    if (isLoading) {
      return (
        <div className="flex items-center justify-center p-8">
          <Loader className="w-6 h-6 animate-spin text-blue-500" />
          <span className="ml-2">認証確認中...</span>
        </div>
      );
    }

    if (!isAuthenticated) {
      return (
        <div className="text-center p-8 bg-red-50 border border-red-200 rounded-lg">
          <AlertCircle className="w-8 h-8 text-red-500 mx-auto mb-2" />
          <p className="text-red-700 font-medium">認証が必要です</p>
          <p className="text-red-600 text-sm mt-1">
            このページにアクセスするにはログインしてください。
          </p>
          <button
            onClick={() => window.location.reload()}
            className="mt-3 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors"
          >
            再試行
          </button>
        </div>
      );
    }

    return <WrappedComponent {...props} />;
  };
};

// HOC パターン - ローディング状態の管理
const withLoading = (WrappedComponent) => {
  return (props) => {
    const [isLoading, setIsLoading] = useState(true);
    const [data, setData] = useState(null);

    useEffect(() => {
      // データ取得のシミュレーション
      setTimeout(() => {
        setData({
          users: [
            { id: 1, name: '田中太郎', role: 'Admin' },
            { id: 2, name: '佐藤花子', role: 'User' },
            { id: 3, name: '鈴木一郎', role: 'Moderator' }
          ],
          lastUpdate: new Date().toLocaleString()
        });
        setIsLoading(false);
      }, 2000);
    }, []);

    if (isLoading) {
      return (
        <div className="flex flex-col items-center justify-center p-12">
          <Loader className="w-8 h-8 animate-spin text-blue-500 mb-3" />
          <p className="text-gray-600">データを読み込み中...</p>
        </div>
      );
    }

    return <WrappedComponent {...props} data={data} />;
  };
};

// HOC パターン - エラーハンドリング
const withErrorBoundary = (WrappedComponent) => {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = { hasError: false, error: null };
    }

    static getDerivedStateFromError(error) {
      return { hasError: true, error };
    }

    componentDidCatch(error, errorInfo) {
      console.error('Error caught by HOC:', error, errorInfo);
    }

    render() {
      if (this.state.hasError) {
        return (
          <div className="text-center p-8 bg-yellow-50 border border-yellow-200 rounded-lg">
            <AlertCircle className="w-8 h-8 text-yellow-500 mx-auto mb-2" />
            <p className="text-yellow-700 font-medium">エラーが発生しました</p>
            <p className="text-yellow-600 text-sm mt-1">
              {this.state.error?.message || '不明なエラーです'}
            </p>
            <button
              onClick={() => this.setState({ hasError: false, error: null })}
              className="mt-3 px-4 py-2 bg-yellow-500 text-white rounded-md hover:bg-yellow-600 transition-colors"
            >
              再試行
            </button>
          </div>
        );
      }

      return <WrappedComponent {...this.props} />;
    }
  };
};

// HOC パターン - パフォーマンス監視
const withPerformanceMonitoring = (WrappedComponent) => {
  return (props) => {
    const [renderTime, setRenderTime] = useState(0);
    const [renderCount, setRenderCount] = useState(0);

    useEffect(() => {
      const startTime = performance.now();

      const endTime = performance.now();
      setRenderTime(endTime - startTime);
      setRenderCount(prev => prev + 1);
    });

    return (
      <div>
        <div className="mb-2 p-2 bg-gray-100 rounded text-xs text-gray-600 flex items-center gap-2">
          <Activity className="w-3 h-3" />
          レンダー回数: {renderCount} | 最終レンダー時間: {renderTime.toFixed(2)}ms
        </div>
        <WrappedComponent {...props} />
      </div>
    );
  };
};

// 基本コンポーネント例
const Dashboard = ({ data }) => {
  return (
    <div className="p-6 bg-white rounded-lg shadow-md">
      <div className="flex items-center gap-2 mb-4">
        <Shield className="w-6 h-6 text-green-500" />
        <h2 className="text-xl font-bold">管理者ダッシュボード</h2>
      </div>

      <div className="grid gap-4 md:grid-cols-2">
        <div className="p-4 bg-blue-50 rounded-lg">
          <h3 className="font-semibold text-blue-800 mb-2">システム情報</h3>
          <p className="text-blue-700 text-sm">
            最終更新: {data?.lastUpdate || 'N/A'}
          </p>
        </div>

        <div className="p-4 bg-green-50 rounded-lg">
          <h3 className="font-semibold text-green-800 mb-2">ユーザー統計</h3>
          <p className="text-green-700 text-sm">
            登録ユーザー数: {data?.users?.length || 0}人
          </p>
        </div>
      </div>

      {data?.users && (
        <div className="mt-4">
          <h3 className="font-semibold mb-2">ユーザー一覧</h3>
          <div className="space-y-2">
            {data.users.map(user => (
              <div key={user.id} className="flex items-center gap-3 p-2 bg-gray-50 rounded">
                <User className="w-4 h-4 text-gray-500" />
                <span className="font-medium">{user.name}</span>
                <span className="text-sm text-gray-500">({user.role})</span>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

const UserProfile = () => {
  return (
    <div className="p-6 bg-white rounded-lg shadow-md">
      <div className="flex items-center gap-2 mb-4">
        <User className="w-6 h-6 text-blue-500" />
        <h2 className="text-xl font-bold">ユーザープロフィール</h2>
      </div>

      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">名前</label>
          <input
            type="text"
            defaultValue="田中太郎"
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">メールアドレス</label>
          <input
            type="email"
            defaultValue="tanaka@example.com"
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>

        <button className="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors">
          保存
        </button>
      </div>
    </div>
  );
};

const DataTable = () => {
  const [error, setError] = useState(false);

  const triggerError = () => {
    setError(true);
    throw new Error('テスト用のエラーです');
  };

  return (
    <div className="p-6 bg-white rounded-lg shadow-md">
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-2">
          <Database className="w-6 h-6 text-purple-500" />
          <h2 className="text-xl font-bold">データテーブル</h2>
        </div>
        <button
          onClick={triggerError}
          className="px-3 py-1 bg-red-500 text-white text-sm rounded hover:bg-red-600 transition-colors"
        >
          エラーテスト
        </button>
      </div>

      <div className="overflow-x-auto">
        <table className="w-full text-sm">
          <thead>
            <tr className="border-b">
              <th className="text-left py-2">ID</th>
              <th className="text-left py-2">名前</th>
              <th className="text-left py-2">ステータス</th>
            </tr>
          </thead>
          <tbody>
            <tr className="border-b">
              <td className="py-2">001</td>
              <td className="py-2">プロジェクトA</td>
              <td className="py-2">
                <span className="px-2 py-1 bg-green-100 text-green-800 rounded-full text-xs">
                  完了
                </span>
              </td>
            </tr>
            <tr className="border-b">
              <td className="py-2">002</td>
              <td className="py-2">プロジェクトB</td>
              <td className="py-2">
                <span className="px-2 py-1 bg-yellow-100 text-yellow-800 rounded-full text-xs">
                  進行中
                </span>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  );
};

// HOCを適用したコンポーネント
const AuthenticatedDashboard = withAuth(withLoading(Dashboard));
const SecureUserProfile = withAuth(UserProfile);
const MonitoredDataTable = withPerformanceMonitoring(withErrorBoundary(DataTable));

// メインコンポーネント
const HOCDemo = () => {
  const [activeComponent, setActiveComponent] = useState('dashboard');

  const components = [
    { id: 'dashboard', label: '認証 + ローディング', component: <AuthenticatedDashboard /> },
    { id: 'profile', label: '認証のみ', component: <SecureUserProfile /> },
    { id: 'table', label: 'エラーハンドリング + パフォーマンス監視', component: <MonitoredDataTable /> }
  ];

  return (
    <div className="max-w-4xl mx-auto p-6 bg-gray-50 min-h-screen">
      <h1 className="text-2xl font-bold mb-6">Higher-Order Component (HOC) パターン</h1>

      <div className="space-y-6">
        <div className="bg-white p-4 rounded-lg border">
          <h3 className="font-semibold mb-2">概要</h3>
          <p className="text-sm text-gray-600">
            コンポーネントを受け取って、拡張された新しいコンポーネントを返すパターン。
            認証、ローディング、エラーハンドリングなどの横断的関心事を分離できます。
          </p>
        </div>

        {/* コンポーネント選択 */}
        <div className="bg-white p-4 rounded-lg border">
          <h3 className="font-semibold mb-3">コンポーネント選択</h3>
          <div className="flex flex-wrap gap-2">
            {components.map(comp => (
              <button
                key={comp.id}
                onClick={() => setActiveComponent(comp.id)}
                className={`px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                  activeComponent === comp.id
                    ? 'bg-blue-500 text-white'
                    : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                }`}
              >
                {comp.label}
              </button>
            ))}
          </div>
        </div>

        {/* 選択されたコンポーネントの表示 */}
        <div>
          {components.find(comp => comp.id === activeComponent)?.component}
        </div>

        {/* HOCの説明 */}
        <div className="bg-orange-50 p-4 rounded-lg">
          <h3 className="font-semibold text-orange-800 mb-2">実装されているHOC</h3>
          <ul className="text-sm text-orange-700 space-y-1">
            <li>• <strong>withAuth</strong>: 認証状態をチェックし、未認証時はログイン画面を表示</li>
            <li>• <strong>withLoading</strong>: データ取得中のローディング状態を管理</li>
            <li>• <strong>withErrorBoundary</strong>: エラーをキャッチして適切なUI を表示</li>
            <li>• <strong>withPerformanceMonitoring</strong>: レンダリング回数と時間を監視</li>
          </ul>
        </div>

        <div className="bg-indigo-50 p-4 rounded-lg">
          <h3 className="font-semibold text-indigo-800 mb-2">メリット</h3>
          <ul className="text-sm text-indigo-700 space-y-1">
            <li>• 横断的関心事を分離できる</li>
            <li>• 既存コンポーネントを変更せずに機能追加可能</li>
            <li>• 再利用性が高い</li>
            <li>• 複数のHOCを組み合わせて使用可能</li>
          </ul>
        </div>
      </div>
    </div>
  );
};

export default HOCDemo;
```
