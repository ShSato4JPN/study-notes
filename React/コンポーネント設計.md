# React Compositionパターン

React Compositionパターンは、コンポーネントの再利用性と柔軟性を高めるための設計パターンです。継承ではなく合成（composition）を使って、コンポーネント間の関係を構築します。

## 概要

Compositionパターンでは、親コンポーネントが子コンポーネントの構造や内容を決定するのではなく、子コンポーネントを受け取って組み合わせます。これにより、より柔軟で再利用可能なコンポーネントを作成できます。

主な利点：

- コンポーネントの責任が明確に分離される
- 再利用性が向上する
- プロップドリリング問題を軽減できる
- より柔軟なUI構造を実現できる

## サンプルコード上記のサンプルコードでは、React Compositionパターンの4つの主要な手法を実装しています

## 1. Children Props パターン

最もシンプルな合成パターンで、`children` propを使って子要素を受け取ります。Cardコンポーネントのように、外殻となるコンポーネントの中身を外部から決定できます。

## 2. Render Props パターン

関数をpropとして受け取り、その関数にデータを渡してレンダリングを委譲します。DataFetcherコンポーネントでは、データの取得ロジックとUIの表示を分離しています。

## 3. Compound Components パターン

複数のコンポーネントが協調して動作するパターンです。Dropdownコンポーネントのように、関連するコンポーネントをまとめて、統一されたAPIを提供します。

## 4. Higher-Order Component (HOC) パターン

コンポーネントを受け取って、機能を追加した新しいコンポーネントを返します。認証チェックのような横断的関心事を分離できます。

これらのパターンを適切に使い分けることで、保守性が高く再利用可能なReactアプリケーションを構築できます。

```jsx
import React, { useState } from 'react';

// 1. Children Props パターン
const Card = ({ children, title }) => {
  return (
    <div className="border border-gray-300 rounded-lg p-4 m-2 shadow-sm">
      <h3 className="text-lg font-semibold mb-2">{title}</h3>
      {children}
    </div>
  );
};

// 2. Higher-Order Component (HOC) パターン
const withToggle = (WrappedComponent) => {
  return function WithToggleComponent(props) {
    const [isVisible, setIsVisible] = useState(true);

    return (
      <div>
        <button
          onClick={() => setIsVisible(!isVisible)}
          className="mb-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
        >
          {isVisible ? '隠す' : '表示'}
        </button>
        {isVisible && <WrappedComponent {...props} />}
      </div>
    );
  };
};

const SimpleText = ({ text }) => (
  <p className="text-gray-700">{text}</p>
);

const ToggleableText = withToggle(SimpleText);

// 3. Render Props パターン
const MouseTracker = ({ render }) => {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  const handleMouseMove = (e) => {
    setPosition({ x: e.clientX, y: e.clientY });
  };

  return (
    <div
      onMouseMove={handleMouseMove}
      className="h-32 bg-gray-100 border border-gray-300 rounded"
    >
      {render(position)}
    </div>
  );
};

// 4. Compound Components パターン
const Modal = ({ children, isOpen, onClose }) => {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-white rounded-lg max-w-md w-full mx-4">
        {children}
      </div>
    </div>
  );
};

Modal.Header = ({ children }) => (
  <div className="px-6 py-4 border-b border-gray-200">
    <h2 className="text-xl font-semibold">{children}</h2>
  </div>
);

Modal.Body = ({ children }) => (
  <div className="px-6 py-4">
    {children}
  </div>
);

Modal.Footer = ({ children }) => (
  <div className="px-6 py-4 border-t border-gray-200 flex justify-end space-x-2">
    {children}
  </div>
);

// メインコンポーネント
export default function CompositionExample() {
  const [isModalOpen, setIsModalOpen] = useState(false);

  return (
    <div className="p-4 max-w-4xl mx-auto">
      <h1 className="text-2xl font-bold mb-6">React Composition パターンの例</h1>

      {/* 1. Children Props の例 */}
      <Card title="Children Props パターン">
        <p>このテキストはchildrenとして渡されています。</p>
        <button className="mt-2 px-3 py-1 bg-green-500 text-white rounded">
          ボタンも入れられます
        </button>
      </Card>

      {/* 2. HOC の例 */}
      <Card title="Higher-Order Component パターン">
        <ToggleableText text="このテキストは表示/非表示を切り替えできます。" />
      </Card>

      {/* 3. Render Props の例 */}
      <Card title="Render Props パターン">
        <p className="mb-2">マウスをボックス内で動かしてください：</p>
        <MouseTracker
          render={(position) => (
            <div className="p-4">
              <p>マウス位置: X: {position.x}, Y: {position.y}</p>
            </div>
          )}
        />
      </Card>

      {/* 4. Compound Components の例 */}
      <Card title="Compound Components パターン">
        <button
          onClick={() => setIsModalOpen(true)}
          className="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600"
        >
          モーダルを開く
        </button>

        <Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}>
          <Modal.Header>
            確認ダイアログ
          </Modal.Header>
          <Modal.Body>
            <p>これはCompound Componentsパターンで作られたモーダルです。</p>
            <p>各部分（Header、Body、Footer）が独立したコンポーネントになっています。</p>
          </Modal.Body>
          <Modal.Footer>
            <button
              onClick={() => setIsModalOpen(false)}
              className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600"
            >
              閉じる
            </button>
            <button
              onClick={() => setIsModalOpen(false)}
              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              OK
            </button>
          </Modal.Footer>
        </Modal>
      </Card>
    </div>
  );
}

Compositionパターンとは、複雑な機能を持つコンポーネントを小さな単機能コンポーネントの組み合わせで構築する設計パターンです。
核心的な考え方
「継承よりも合成を優先する」という原則に基づいています。1つの大きなコンポーネントにすべての機能を詰め込むのではなく、シンプルな部品を作って、それらを組み合わせて複雑な機能を実現します。
具体的には
従来のアプローチ（継承的思考）:

「スーパーボタン」のような万能コンポーネントを作る
プロップスで「タイプ」「サイズ」「色」などを指定
新しい機能が必要になる度にif文やswitch文が増える

Compositionパターン:

基本の「Button」コンポーネントを作る
それを元に「PrimaryButton」「LargeButton」などの特化コンポーネントを作る
必要に応じてそれらを組み合わせる

なぜ優れているのか

単一責任の原則: 各コンポーネントが1つのことだけを担当
拡張性: 新しい組み合わせを作るのが簡単
再利用性: 小さな部品は他の場所でも使える
保守性: 変更の影響範囲が限定される
テスタビリティ: 小さな単位でテストできる

React特有の要素
Reactではchildrenプロパティを使って、親コンポーネントが子の内容を柔軟に決められるため、Compositionパターンが特に効果的です。これにより「何を表示するか」と「どう表示するか」を分離できます。
要するに、レゴブロックのように小さな部品を組み合わせてより大きな機能を作るのがCompositionパターンの本質です。再試行Claudeは間違えることがあります。回答内容を必ずご確認ください。 Sonnet 4
